<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>VHDL加法器准备</title>
      <link href="/2023/12/02/VHDL%E5%8A%A0%E6%B3%95%E5%99%A8%E5%87%86%E5%A4%87/"/>
      <url>/2023/12/02/VHDL%E5%8A%A0%E6%B3%95%E5%99%A8%E5%87%86%E5%A4%87/</url>
      
        <content type="html"><![CDATA[<h1 id="chapter2-布尔函数的逻辑实现">chapter2 布尔函数的逻辑实现</h1><h2 id="节-数字电路的-vhdl-描述">2.3节 数字电路的 VHDl 描述</h2><h3 id="vhdl程序的基本结构">2. VHDL程序的基本结构</h3><p>（1）实体（ENTITY）</p><ul><li>设计单元的外部特征（输入、输出信号）</li><li>对应于原理图中的电路符号</li></ul><p>（2）结构体（ARCHITECTURE）</p><ul><li>输入输出信号的逻辑关系</li><li>对应于电路的内部结构</li></ul><p>（3）库（LIBRARY）</p><ul><li>库中保存了已编译的可用资源，可以为任何设计者共享</li></ul><p>（4）包集合</p><ul><li>存放可以为同一系统所有实体共享的数据类型、常量、子程序的集合</li></ul><p>（5）配置（CONFIGUARTION）</p><ul><li>一个实体可以有多个结构体实现版本</li><li>配置是在实例化具有多个结构体实现版本的实体时，选择其一作为实实际应用的结构体</li></ul><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/001.png"alt="001" /><figcaption aria-hidden="true">001</figcaption></figure><ol type="1"><li>实体（ENTITY）：外部特征描述</li></ol><blockquote><p>语法格式</p><p>ENTITY 实体名 IS [GENERUIC(类属表)]; [PORT(端口表)]; END [ENTITY]实体名；</p></blockquote><ol start="2" type="1"><li>结构体（Architecture）：内部功能描述</li></ol><blockquote><p>语法格式</p><p>ARCHITECTURE 结构体名 OF 实体名 IS [结构体说明部分] BEGIN[并发处理语句]; END 结构体名;</p></blockquote><p>（1）结构体说明部分</p><ul><li>用于说明结构体的功能描述语句中将要用到的内容<ul><li>信号：singal</li><li>数据类型：type</li><li>常数：constant</li><li>元件：componment</li><li>函数：function</li><li>过程：procedure</li></ul></li><li>结构体中说明和定义的内容只能用于这个结构体中</li><li>若希望其能应用于其他的实体或者结构体中，则需要将其作为程序包来处理</li></ul><ol start="3" type="1"><li>配置（Configuration）</li></ol><blockquote><p>语法格式</p><p>For 例化元件标号表: 元件名 use entity 实体名(结构体名) [genericmap(参数关联表)]; [port map(端口关联表)];</p></blockquote><h3 id="vhdl的基本语言元素">3.VHDL的基本语言元素</h3><ol type="1"><li><p>标识符</p></li><li><p>数据对象</p><p>（1）常量：constant</p><p>（2）变量：variable</p><p>（3）信号：signal</p><p>（4）信号和变量的区别：</p><table><thead><tr class="header"><th>信号</th><th>变量</th></tr></thead><tbody><tr class="odd"><td>全局量</td><td>暂存数据的单元</td></tr><tr class="even"><td>有延迟</td><td>局部量</td></tr><tr class="odd"><td>&lt;= 赋值</td><td>不允许有延迟</td></tr><tr class="even"><td></td><td>:= 赋值</td></tr></tbody></table></li><li><p>数据类型</p><p>（1）标准数据类型</p><table><colgroup><col style="width: 22%" /><col style="width: 25%" /><col style="width: 52%" /></colgroup><thead><tr class="header"><th>数据类型</th><th>关键字</th><th>取值范围</th></tr></thead><tbody><tr class="odd"><td>整数</td><td>integer</td><td>整数32位</td></tr><tr class="even"><td>实数</td><td>real</td><td>浮点数、</td></tr><tr class="odd"><td>位</td><td>bit</td><td>逻辑1或者0</td></tr><tr class="even"><td>位矢量</td><td>bit vector</td><td>用双引号括起来的一组数据</td></tr><tr class="odd"><td>布尔量</td><td>boolean</td><td>逻辑真或者逻辑假，用True或者Flase</td></tr><tr class="even"><td>字符</td><td>character</td><td>ASCII字符</td></tr><tr class="odd"><td>字符串</td><td>string</td><td>字符矢量</td></tr><tr class="even"><td>时间</td><td>time</td><td>时间单位fs、ps、ns……</td></tr><tr class="odd"><td>自然数、正整数</td><td>Natural Positive</td><td>整数的子集</td></tr><tr class="even"><td>错误等级</td><td>Severity_Level</td><td>note、warning、error、failure</td></tr></tbody></table></li></ol><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/002.png"alt="002" /><figcaption aria-hidden="true">002</figcaption></figure><ol start="4" type="1"><li><p>运算符与操作符</p><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/003.png"alt="003" /><figcaption aria-hidden="true">003</figcaption></figure></li><li><p>属性</p><ul><li>VHDL语言位用户提供了多种能反映和影响硬件行为的属性</li><li>包括设计实体、结构体、类型、信号等项目的指定属性</li><li>属性相当于为获取硬件设计中的一些有关信息而定义的内部函数</li><li>信号属性在检测信号变化和建立详细的时域模型时非常重要</li><li>VHDL属性可以分为：<ul><li>数值类</li><li>函数类</li><li>信号类</li><li>类型类</li><li>范围类</li></ul></li></ul><p>（1）数值类属性：</p><ul><li><p>用于返回数组、块或者一般数据的有关值，如边界、数组长度</p><p>1》Object'left：返回一个数组类型或者子类型最左边的值</p><p>2》Object'right：返回一个数组类型或者子类型最右边的值</p><p>3》Object'high：返回一个数组类型或者子类型的最大值</p><p>4》Object'low：返回一个数组类型或者子类型的最小值</p><p>5》Object'length：返回数组的长度值</p></li></ul><p>（2）函数类属性</p><ul><li><p>属性以函数的形式返回有关数据类型、数组、信号的相关信息</p></li><li><p>函数类属性分三类：</p><ul><li>数据类型属性函数</li><li>数组类型属性函数</li><li>信号属性函数</li></ul><p>1》数据类型属性函数函数</p><ol type="1"><li>Object'succ(X)：获取X的下一个值</li><li>Object'pred(X)： 获取X的前一个值</li><li>Object'leftof(X)：获取X的左边值</li><li>Object'rightof(X)：获取X的右边值</li></ol><p>2》数组的类型函数</p><ol type="1"><li>Object'left(n) ：获取索引号为 n 的区间的左端边界值</li><li>Object'right(n)：获取索引号为 n 的区间的右边边界值</li><li>Object'low(n)：获取索引号为 n 的区间的高端边界值</li><li>Object'low(n)：获取索引号为 n 的区间的低端边界值</li></ol><p>3》信号的属性函数</p><ol type="1"><li>Object'event：信号的值是否发生变化，如果是，则返回 真</li><li>Object'active：信号是否活跃，如果是，就返回 真</li><li>Object'last_event：从最近一次事件到现在经过的时间，返回时间值</li><li>Object'last_value：信号变化前的取值，并将该历史值返回</li><li>Object'last_active：从最近一次活跃，到现在，经过的时间，返回时间值</li></ol></li></ul></li></ol><h3 id="vhdl的顺序语句">4.VHDL的顺序语句</h3><ul><li>在 VHDL 语言中顺序描述语句有以下几种：<ol type="1"><li>信号代入语句 &lt;=</li><li>变量赋值语句 :&lt;</li><li>wait</li><li>if</li><li>case</li><li>loop</li><li>next</li><li>exit</li><li>return</li><li>null</li></ol></li></ul><h3 id="vhdl的描述实例">8.VHDL的描述实例</h3><p>​</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> 花自向阳开 </category>
          
          <category> VHDL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 花自向阳开 </tag>
            
            <tag> 小杜的 </tag>
            
            <tag> VHDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>联邦学习入门-01(Communication-Efficient Learning of Deep Networks from Decentralized Data)</title>
      <link href="/2023/11/30/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-01/"/>
      <url>/2023/11/30/%E8%81%94%E9%82%A6%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8-01/</url>
      
        <content type="html"><![CDATA[<h1id="联邦学习入门-01communication-efficient-learning-of-deep-networks-from-decentralized-data">联邦学习入门-01(Communication-EfficientLearning of Deep Networks from Decentralized Data)</h1><p>开山之作: <ahref="https://arxiv.org/pdf/1602.05629.pdf">Communication-EfficientLearning of Deep Networks from Decentralized Data</a></p><p>现代移动设备拥有大量的适合模型学习的数据，基于这些数据训练得到的模型可以极大地提升用户体验。例如，语言模型能提升语音设别的准确率和文本输入的效率，图像模型能自动筛选好的照片。然而，移动设备拥有的丰富的数据经常具有关于用户的敏感的隐私信息且多个移动设备所存储的数据总量很大，这样一来，不适合将各个移动设备的数据上传到数据中心，然后使用传统的方法进行模型训练。作者提出了一个替代方法，这种方法可以基于分布在各个设备上的数据（无需上传到数据中心），然后通过局部计算的更新值进行聚合来学习到一个共享模型。作者定义这种非中心化方法为“联邦学习”。作者针对深度网络的联邦学习任务提出了一种实用方法，这种方法在学习过程中多次对模型进行平均。同时，作者使用了五种不同的模型和四个数据集对这种方法进行了实验验证。实验结果表明，这种方法面对不平衡以及非独立同分布的数据，具有较好的鲁棒性。在这种方法中，通信所产生的资源开销是主要的瓶颈，实验结果表明，与同步随机梯度下降相比，该方法的通信轮次减少了10-100倍。</p><h2id="联邦学习联邦学习有如下的属性">联邦学习：联邦学习有如下的属性</h2><p>从多个移动设备中存储的真实数据中进行模型训练比从存储在数据中心的数据中进行模型训练更具优势；由于数据具有隐私，且多个移动设备所存储的数据总量很大，因此不适合将其上传至数据中心再进行模型训练；对于监督学习任务，数据中的标签信息可以从用户与应用程序的交互中推断出来。</p><h2 id="隐私">隐私</h2><p>相比于中心化数据的训练方法，联邦学习方法在隐私方面具有很大的优势。即使将数据进行匿名化之后，如果联合其他数据依然有可能泄露用户隐私。相反，联邦学习过程中的信息传输是为了改进一个模型的最小的必要信息（隐私保护的强度依赖于更新值）。这些更新值本身是“短暂的”，即它们所包含的信息量不高于原始数据所含的信息量（通过数据处理不等式说明），并且一般是更新值包含很少的信息量。由于聚合算法不需要关于更新值的来源信息，所以，不需要通过混合网络（例如Tor）来识别元数据或基于一个可信的第三方就可以传输更新值。在本文末尾，作者简要讨论了一下将联邦学习与多方安全计算和差分隐私进行融合的可能性。</p><h2 id="联邦优化">联邦优化</h2><p>作者将联邦学习中隐含的优化问题称为联邦优化，其与分布式优化有着密切的联系。较之于典型的分布式优化问题，联邦优化有很多不同的地方：</p><ul><li><p><strong>非独立同分布</strong>：一个客户端存储的训练数据主要是基于一个特定用户在使用该移动设备的过程中产生的，因此，任何一个用户的本地数据集都不能表示整体分布。</p></li><li><p><strong>非平衡</strong>：类似地，一些用户可能对某项服务或某个应用软件使用比其他用户频繁，则在该客户端上将产生大量的训练数据。</p></li><li><p><strong>大规模分布</strong>：作者预计参与优化的客户端数量将远远大于所有客户端所拥有的数据量总量的平均数。即：若设有<spanclass="math inline">\(D\)</span>个客户端参与优化，每个客户端的数据量分布为<spanclass="math inline">\(N_i, i=1,2,...,D\)</span>，则有 <spanclass="math inline">\(D \gg\frac{1}{D}\sum_{i=1}^D{N_i}\)</span>。</p></li><li><p><strong>通信受限</strong>：移动设备具有经常掉线、传输速率低以及通信成本高的特点</p></li></ul><p>本文，作者重点关注优化任务中的非独立同分布和不平衡的问题，以及通信受限的临界属性。一个可以部署的联邦优化系统必须能够解决很多问题：</p><ol type="1"><li>由于数据被添加或删除导致客户端数据集发生了变动；</li><li>客户端的可用性与其存储的数据分布具有复杂的关系（例如，说美式英语的人使用的手机与说英式英语的手机，这两个客户端具有可用性的时间段不一样）；</li><li>可能会存在从来不响应的客户端或着发送已损毁的更新值的客户端；</li></ol><p>这些问题超出了本文的研究范围。作者在一个人为控制的实验环境下进行实验，但是这种实验环境仍然存在客户端可用性和数据非平衡以及非独立同分布的关键问题。作者假设一个同步更新框架，通过多轮通信进行更新。现有固定的<spanclass="math inline">\(K\)</span>个客户端，每个客户端拥有一个固定的本地数据集。每轮更新的开始，随机选择<spanclass="math inline">\(C\)</span>个客户端，并且服务器给每个客户端发送现有的全局算法状态（例如算法状态可以是当前全局模型的参数值）。在每轮学习过程中仅选用一部分客户端是为了提升性能，因为实验表明，<strong>当客户端超过一定数量后学习性能会下降。每一个被选择的客户端基于本地存储的数据以及全局状态进行计算更新，然后将更新后的算法状态发送给服务器。服务器利用客户端发送回来的算法状态对全局状态进行更新，并且重复这个过程。</strong></p><p>虽然作者关注于非凸的神经网络目标函数，但作者认为该算法适用于以下形式的目标函数，该目标函数为任何有限个目标函数的和：<span class="math display">\[\begin{align}\min_{w\in{\mathbb{R}^{d}}}f(w) \qquad wh &amp; ere\quadf(w)\overset{def}{=} \frac{1}{n}\sum^n_{i=1}f_i(w)\end{align}\]</span> 对于一个机器学习问题，设<spanclass="math inline">\(f_i(w)=loss(x_i,y_i;w)\)</span>则其表示给定模型参数<spanclass="math inline">\(w\)</span>的条件下，关于第<spanclass="math inline">\(i\)</span>个样本<span class="math inline">\((x_i,y_i)\)</span>的损失。我们假设有<spanclass="math inline">\(K\)</span>个客户端,<spanclass="math inline">\(\mathcal{P}_k\)</span>表示第<spanclass="math inline">\(k\)</span>个客户端的数据点的索引集，<spanclass="math inline">\(n_k = |\mathcal{P}_k|\)</span>为第<spanclass="math inline">\(k\)</span>个客户端所拥有的数据量。上述目标函数（1）可以重新写为：<span class="math display">\[\begin{align}f(w)=\sum^{K}_{k=1} \frac{n_k}{n}F_k(w) \qquad wh &amp; ere\qquadF_k(w)=\frac{1}{n_k}\sum_{i \in \mathcal{p_k}}f_i(w)\end{align}\]</span> 其中 <span class="math inline">\(n =\sum^{K}_{k=1}n_k\)</span></p><p>如果将全部数据集随机均匀地分配到每个客户端中，即所有的<spanclass="math inline">\(\mathcal{P}_k\)</span>均为独立同分布的数据集，则有<span class="math inline">\(\mathbb{E}_{p_k}[F_k(w)] =f(w)\)</span>，等式左边表示的是关于分配给每个客户端的数据上的平均损失的期望。这是分布式优化算法采用的典型的独立同分布假设；作者考虑的是不满足独立同分布假设的情况（即,<spanclass="math inline">\(F_k\)</span>是一个对<spanclass="math inline">\(f\)</span>任意的糟糕的近似）。</p><p>在数据中心存储的优化中，通信开销相对较小，计算开销占主导地位，最近很多研究工作强调使用GPU可以降低计算开销。相反，在联邦优化中，通信开销占主导地位—作者将上传带宽限制为1MB/s或更少。此外，客户段通常只有在充电、接通电源和未计费的Wi-Fi连接时才会参与优化。此外，作者希望每个客户端每天仅仅参与一小部分轮次的训练。另一方面，因为相比于全部数据，任何一个单一设备所具有的数据量较少，且现代手机有相对快的处理器（包括GPU），所以对于很多类型的模型，较之于通信开销，计算不是一个主要问题。因此，本文目的是使用额外的计算来减少训练模型所需通信的轮次。有两种基本的额外计算方法：</p><ol type="1"><li>提高并行度，每两轮通信间，使用更多的独立工作的客户端；</li><li>增加每个客户端的计算：每个客户端除了执行一个简单的计算（比如计算梯度），还要在每两轮通信间进行更复杂的计算；</li></ol><p>​作者研究了这两种方法，但是一旦使用了最低级别的客户端并行性，则主要通过在每个客户端上添加了更多的计算来实验加速（这里的加速指的是减少了通信轮次）。</p><p><strong>相关工作</strong>：McDonald等人<a href="#fn1"class="footnote-ref" id="fnref1"role="doc-noteref"><sup>1</sup></a>研究了通过迭代平均本地训练的模型来对感知机进行分布式训练，Povey等人<ahref="#fn2" class="footnote-ref" id="fnref2"role="doc-noteref"><sup>2</sup></a>研究了语音识别深度神经网络的分布式训练，Zhang等人<ahref="#fn3" class="footnote-ref" id="fnref3"role="doc-noteref"><sup>3</sup></a>研究了使用“软”平均的异步训练方法。这些研究工作仅考虑了数据中心化背景（最多有16个工作节点，以及使用了快速传输网络）下的任务，并没有考虑具有数据不平衡且非独立同分布特点的联邦学习任务。作者使用这种风格（即迭代平均本地训练的模型）的算法来解决联邦学习问题，并且进行了适当的实验评估，基于这样的研究，提出与数据中心化设置中不同的问题，并且在联邦学习中这种算法需要结合不同的方法。</p><p>与本文的研究动机相似，Neverova等人<a href="#fn4" class="footnote-ref"id="fnref4"role="doc-noteref"><sup>4</sup></a>也讨论了保护设备中的用户数据的隐私的优点。Shokri和Shmatikov的研究工作与本文研究工作有一些相似之处：他们关注于训练深度网络，<strong>强调隐私的重要性以及通过在每一轮通信中仅共享一部分参数，进而降低通信开销</strong>；然而，他们也没有考虑数据的不平衡以及非独立同分布性，并且他们的研究工作缺乏实验评估。</p><p>在“凸”背景下，分布式优化和评估的问题被广泛研究，并且一些算法特别关注了通信效率。除了凸假设，已有的研究研究工作一般要求客户端数量远小于每个客户端的样本数量，这样在各个客户端之间数据（每个客户端的数据量相同）是独立同分布的。这些假设在联邦优化中均不成立。分布式随机梯度下降的异步形式也被应用于神经网络的训练中，例如：Dean等人<ahref="#fn5" class="footnote-ref" id="fnref5"role="doc-noteref"><sup>5</sup></a>的研究工作，但是这些方法要求在联邦学习中进行大量的更新。分布式共识算法[41]弱化了独立同分布假设，但是仍然没有解决在通信受限的条件下，大量客户端进行联邦学习的问题。</p><p>作者认为（参数化）算法就是简单的one-shot（一次性）平均，其中每个客户端使得模型在本地数据集上的损失最小，通过平均这些模型来产生最终的全局模型。这种方法已经在凸情况以及数据独立同分布背景下被广泛研究，并且最坏的情况是，全局模型没有比单一客户端训练的模型更好。</p><h2 id="联邦平均算法">联邦平均算法</h2><p>最近深度学习取得巨大成功在很大程度上依赖于随机梯度下降优化算法及其变种；事实上，在很多应用方面的进步可以理解为，采用了易于使用梯度下降进行优化的模型结构（以及损失函数）<ahref="#fn6" class="footnote-ref" id="fnref6"role="doc-noteref"><sup>6</sup></a>。因此，作者在构建联邦优化算法时自然地使用了随机梯度下降。</p><p>随机梯度下降天然地可以被用于联邦优化，因为，每轮通信完成一次基于一个批次数据的梯度计算（在被随机选择的客户端上进行）。这种方法具有很高的计算效率，但是若想学习出好的模型，需要大量轮次的训练（甚至即使使用了一个如批次归一化的高级方法，Ioffe和Szegedy<ahref="#fn7" class="footnote-ref" id="fnref7"role="doc-noteref"><sup>7</sup></a>构建手写数字识别的模型训练了50000轮，每次训练使用60个样本），作者在CIFAR-10数据集上的实验考虑了该基准（即训练出好的模型所需要的训练次数）。</p><p>在联邦框架下，更多用户的参与几乎不会增加时间消耗，所以作者使用大批量同步随机梯度下降法做为对比的基准，因为Chen等人[8]的实验验证了该方法在数据中心化学习框架下可以达到很好的效果，且优于异步方法。为了在联邦学习中应用该方法，作者每轮选择<spanclass="math inline">\(C\)</span>比例的客户端，在这些客户端上基于全部数据计算损失函数的梯度值。因此，<spanclass="math inline">\(C\)</span>控制了全局批次大小，如果<spanclass="math inline">\(C=1\)</span>，那么意味着全批次梯度下降。作者称这种基线算法为联邦随机梯度下降。</p><p>参数更新方式有两种, 一种典型的联邦随机梯度下降设置<spanclass="math inline">\(c=1\)</span> 以及一个固定的学习率<spanclass="math inline">\(\eta\)</span>：</p><ol type="1"><li><strong>典型的联邦随机梯度下降</strong>第 <spanclass="math inline">\(k\)</span>个客户端计算梯度为 <spanclass="math inline">\(g_k = \bigtriangledownF_k(w_t)\)</span>，中心服务器聚合每个客户端计算的梯度以此来更新模型参数，即：</li></ol><p><span class="math display">\[\begin{align}w_{t+1} \gets w_t - \eta\sum_{k=1}^K\frac{n_k}{n}g_k = w_t -\eta\bigtriangledown f(w_t)\end{align}\]</span></p><p>其中，$ _{k=1}^Kg_k = f(w_t)$</p><ol start="2" type="1"><li><strong>另一种等价更新方法</strong>为，每个客户端给予本地数据分别各自对当前模型参数<span class="math inline">\(w_t\)</span>进行更新，即：</li></ol><p><span class="math display">\[\begin{align}w^k_{t+1} \gets w_t - \eta g_k\end{align}\]</span></p><p>然后中心服务器对每个客户端更新后的参数进行加权平均： <spanclass="math display">\[\begin{align}w_{t+1} \gets \sum^{K}_{k=1}\frac{n_k}{n}w^k_{t+1}\end{align}\]</span>按照第二种参数更新方法，每个客户端可以独立地更新模型参数多次，然后再将更新好的参数发送给中心服务器进行加权平均。</p><p>作者称这种方法为<strong>联邦平均（FedAvg）</strong>。算法的计算量与三个参数有关：</p><ol type="1"><li><spanclass="math inline">\(C\)</span>：每轮训练选择客户端的比例；</li><li><spanclass="math inline">\(E\)</span>：每个客户端更新参数的循环次数所设计的一个因子；</li><li><spanclass="math inline">\(B\)</span>：客户端更新参数时，每次梯度下降所使用的数据量；</li></ol><p><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/v2-5108ab37b6110d1d962f10590a82a720_720w.webp" /></p><p><strong><em>对于一般的非凸目标函数，在参数空间进行模型平均将得到一个较差的模型</em></strong>。</p><p>根据Goodfellow等人<a href="#fn8" class="footnote-ref" id="fnref8"role="doc-noteref"><sup>8</sup></a>提出的方法，可以看到当平均两个针对手写数字识别模型[^3]（这两个模型从分别从不同的初始条件，如图1左图，进行训练）后，模型表现很差。对于图1对应的实验，参数模型<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(w^{&#39;}\)</span>的训练使用了MNIST数据集中的600个无重复的独立同分布样本。两个模型均使用随机梯度下降法进行训练，学习率为0.1，最小批次数据量为50，总共训练了240轮（即设<span class="math inline">\(E = 20\)</span>，本实验中其他设置为<spanclass="math inline">\(C=1\)</span>，<spanclass="math inline">\(B=50\)</span>中心服务器总共聚合了一次）。这大约是模型开始过度拟合其本地数据集的训练量。</p><p><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/v2-9cd2921fc485fb85c4ce14d1c661e3dc_720w.webp" /></p><p>图1：左图为，将两个参数模型<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(w^{&#39;}\)</span>进行加权平均，<spanclass="math inline">\(\theta w + (1 - \theta)w^{&#39;}\)</span>，<spanclass="math inline">\(\theta\)</span>的取值为在$ [−0.2,1.2] $内等间隔的取50个点，然后基于每个加权平均后的模型计算关于整个MNIST数据集的损失。参数模型<span class="math inline">\(w\)</span> 和 <spanclass="math inline">\(w^{&#39;}\)</span>分别在不同的小规模数据集上使用随机梯度下降法进行训练。作图的实验，使用了不同的随机种子对<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(w^{&#39;}\)</span>进行初始化。右图的实验，<strong>使用了相同的随机种子对<spanclass="math inline">\(w\)</span>和<spanclass="math inline">\(w^{&#39;}\)</span>进行了初始化</strong>。注意到左右两图的<spanclass="math inline">\(y\)</span>轴的尺度不同。对应于 <spanclass="math inline">\(\theta = 0\)</span> 和 <spanclass="math inline">\(\theta = 1\)</span>，图中灰色水平线标注了损失，此时相当于是单个模型的损失。<strong>通过设置两个模型参数相同的初始值，对模型进行平均可以显著减少模型关于整个训练集的损失（比单一模型的损失要好得多）</strong>。</p><p>最近的研究表明，在实践中，足够过度参数化的神经网络的损耗，表面上会表现得非常好，特别是不太可能会出现不良的局部最小值。事实上，当从相同的随机初始参数值开始训练的两个模型，然后在不同的数据子集上独立训练每个模型（如上所述），发现朴素的参数平均法效果非常好（如图1右侧所示）。<strong>朴素的参数平均法为<span class="math inline">\(\frac{1}{2}w +\frac{1}{2}w^{&#39;}\)</span>，与其它加权平均方式相比，在MNIST训练集上实现了充分小的损失</strong>。虽然图1对应的实验从随机初始化开始，但请注意，每轮联邦平均都使用相同的起始模型参数值<spanclass="math inline">\(w_t\)</span>，因此该直觉（即使用相同的参数初始值，且使用朴素的参数平均法）同样适用。</p><h2 id="实验部分">实验部分</h2><p>作者在图像分类和语言模型两种任务上进行了实验，好的图像识别模型和语言模型可以提升移动设备的可用性。对于这些任务中的每一个，首先选择了一个足够大的代表性数据集，以便可以彻底研究联邦平均算法的超参数的影响。虽然每个单独的模型训练规模相对较小，但作者在实验中训练了2000多个单独的模型。然后，给出了基准数据集CIFAR-10的图像分类任务的结果。最后，在真实情况中，数据是被自然划分的。为了证明联邦平均算法在客户端上处理实际问题的有效性，作者在一个大型语言建模任务对算法进行了评估。</p><p>作者的初始研究包括三种类型的模型和两个数据集，前两个模型是针对MNIST手写数字识别任务的：</p><ol type="1"><li>拥有两个隐藏层，每层200个神经元的多层感知机模型，使用ReLu激活函数（总共有199210个参数），称该模型为“MNIST2NN”。</li><li>拥有两个 5×5卷积层的CNN模型，第一层有32个通道，第二层有64个通道，每层卷积层后跟随有2×2的最大池化层，然后接一个拥有512个神经元的全连接层，使用ReLu激活函数，最后接一个softmax输出层（总共有1663370个参数）</li></ol><p>为了研究联邦优化，需要定制数据在各个客户端上的分布。作者研究了两种方法对MNIST数据在各个客户端上进行划分：一种是独立同分布，数据被打乱，然后给每个客户端分配600个样本，总共有100个客户端；另一种是非独立同分布，首先根据图像标签对数据进行排序，然后按序划分成200份，每份300个样本，然后给每个客户端分配两份数据集，总共有100个客户端。这是一种病态的数据非独立同分布划分方式，因为每个客户端仅有两类样本。因此，因此，这种做法可以探索本文所提算法在高度非IID数据上的表现。</p><p>随机梯度下降对于学习率<spanclass="math inline">\(\theta\)</span>是敏感的。实验基于充分大范围的学习率进行多次训练（<strong><em>对<spanclass="math inline">\(\theta\)</span>值进行网格搜素，取了代表性的11-13个<spanclass="math inline">\(\theta\)</span>值</em></strong>）。作者检查确定了最优的学习率是在网格中间，并且最优学习率之间没有很大差别。除非另有说明，作者绘制的指标为，对于每个x轴的值单独选择最佳的学习率。实验表明，最优学习率随其他参数的变动相比变化不大。<strong><em>（即其他参数变化时，对应最优的学习率变化不大）</em></strong></p><h3 id="提高并行度">提高并行度</h3><p>首先使用<span class="math inline">\(C\)</span>比例的客户端进行实验,<spanclass="math inline">\(C\)</span>控制了多客户端的并行数量。表1给出了对于参数<spanclass="math inline">\(C\)</span>对两种MNIST模型的影响。作者列出了为在测试集上实现目标准确率所需要的通信次数。为了获得该实验结果，作者对每种参数的组合设置均进行了实验，并且绘制了测试准确率关于这些参数的变化曲线，使用上述方法选取<spanclass="math inline">\(\theta\)</span>的值，然后通过采用可以使得测试集上的精度达到最佳的取值，使每条曲线单调递增。然后，计算了每条曲线对应的参数设置达到目标准确率时所对应的通信次数，在形成曲线的离散点之间使用线性插值（为了使曲线与目标精度的水平线有交点）。具体如图2所示，其中灰色水平线表示了目标精度。</p><p>当 <span class="math inline">\(B =\infty\)</span>（此时对于MNIST而言，每个客户端每轮均使用本地全部的600个样本进行参数更新）时，客户端的数量比例的增加仅能使模型效果小幅度提升。当设置<spanclass="math inline">\(B = 10\)</span> ，即取较小值时，当<spanclass="math inline">\(C \geq0.1\)</span>时，模型效果有了显著提升，尤其是在非独立同分布的情况下。基于这些结果，对于接下来的大部分实验，实验固定<spanclass="math inline">\(C =0.1\)</span>，该值较好的权衡了通信效率和收敛效率。通过比较<spanclass="math inline">\(B= \infty\)</span>与<span class="math inline">\(B=10\)</span>两种情况，表1的结果显示，通信次数有明显下降，本文接下来会对此进行研究。</p><p><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/v2-28b49cf2ba1d39b45547f922a5d07262_720w.webp" /></p><p>表1：<spanclass="math inline">\(C\)</span>的取值对于模型的影响。在“2NN”模型中设置<span class="math inline">\(E=1\)</span>，在CNN模型中，设置 <spanclass="math inline">\(E=5\)</span>。注意 <span class="math inline">\(C =0.0\)</span>对应着每轮仅选择一个客户端参与训练，因为实验对于MNIST数据集使用了100个客户端，每行实验结果对应于每轮选择1，10，20，50和100个客户端参与训练。表格中的每一项的值代表了在对应参数设置下，实现目标精度（“2NN”模型的目标精度为97%，CNN模型的目标精度为99%）所需的通信次数，每一项括号中的值表示<span class="math inline">\(C=0\)</span>时的通信次数与对应<spanclass="math inline">\(C\)</span>值的通信次数的比值。表中有5种情况（每次使用较大数量的客户端参与训练），模型在允许的时间内未达到目标精度。</p><h3 id="增加每个客户端的计算量">增加每个客户端的计算量</h3><p>在本节，固定<span class="math inline">\(C=0.1\)</span>并且为参与每轮训练的客户端增加更多的计算量，或者降低<spanclass="math inline">\(B\)</span>，或者提高<spanclass="math inline">\(E\)</span>，或者两者均有。图2描绘了在每轮训练中，当每个客户端对参数进行多次局部随机梯度下降时，可以使通信开销显著降低，表2量化了这种提升。每个客户端每轮期望的参数更新次数为<spanclass="math inline">\(\mu=\frac{E}{B}\mathbb{E}[n_k] =\frac{nE}{KB}\)</span>。在表2中对按照该统计值（即<spanclass="math inline">\(\mu\)</span>）对行进行排序。可以看到改变<spanclass="math inline">\(B\)</span>和<spanclass="math inline">\(E\)</span>对<spanclass="math inline">\(\mu\)</span>的提升是有效的。当<spanclass="math inline">\(B\)</span>足够大，可以充分利用客户端硬件上可用的并行性来降低计算时间，因此，在实践中，这应该是首先被调整的参数。</p><p><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/v2-88e026331b43411b37718853b41cfb4f_720w.webp" /></p><p>表2：联邦平均算法与联邦随机梯度下降算法在达到目标精度所需的通信次数方面的比较（第一行设置<spanclass="math inline">\(E=1\)</span>, <spanclass="math inline">\(B=\infty\)</span>）。<spanclass="math inline">\(\mu\)</span>这一列值的计算公式为<spanclass="math inline">\(\mu =\frac{En}{KB}\)</span>，为每轮训练中，客户端进行本地参数更新的次数。</p><p>对于MNIST数据集独立同分布的划分方式，在最终达到目标精度的前提下，每轮训练更新参数更多次将会使得通信次数降低，对于CNN降低了35倍，对于2NN降低了46倍（2NN的实验结果具体见附录A的表四）。但在病态非独立同分布情况下，该降低倍数是较小的，但是仍然有CNN达到了2.8倍和2NN达到了3.7倍。当朴素的将完全由不同数据集（每个数据集包含两个手写数字类）训练出的模型参数平均，可以带来很大的好处。因此，可以看到这个实验结果是联邦平均算法对于非独立同分数据情况下，表现鲁棒的证据。</p><p>本文实验部分展示了联邦学习具有实用性，因为联邦平均可以使用相对少的通信次数就可以得到一个高质量模型，不同模型结构的实验结果均证明了这一结论，包括多层感知机，两个不同的卷积神经网络，一个两层的字符LSTM，和一个大规模词级别的LSTM。</p><p>虽然联邦学习有助于保护隐私，但可以基于差分隐私、安全多方计算，或它们的组合可以具备更强的隐私保护，这是未来工作的研究方向。注意这类技术可以很自然的应用在同步算法上，如联邦平均，在这项工作完成之后，Bonawitz等人<ahref="#fn9" class="footnote-ref" id="fnref9"role="doc-noteref"><sup>9</sup></a>介绍了一种对于联邦学习而言有效的安全聚合协议，并且Konecny等人<ahref="#fn10" class="footnote-ref" id="fnref10"role="doc-noteref"><sup>10</sup></a>提出了一种算法可以进一步降低通信开销。</p><aside id="footnotes" class="footnotes footnotes-end-of-document"role="doc-endnotes"><hr /><ol><li id="fn1"><p>Ryan McDonald, Keith Hall, and Gideon Mann. Distributedtraining strategies for the structured perceptron. In NAACL HLT, 2010.<ahref="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2"><p>Daniel Povey, Xiaohui Zhang, and SanjeevKhudanpur.Parallel training of deep neural networks with naturalgradient and parameter averaging. In ICLR Workshop Track, 2015.<ahref="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3"><p>Sixin Zhang, Anna E Choromanska, and Yann LeCun.Deeplearning with elastic averaging sgd. In NIPS. 2015.<a href="#fnref3"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn4"><p>Natalia Neverova, Christian Wolf, Griffin Lacey, LexFridman, Deepak Chandra, Brandon Barbello, and Graham W. Taylor.Learning human identity from motion patterns. IEEE Access, 4:1810–1820,2016.<a href="#fnref4" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn5"><p>Jeffrey Dean, Greg S. Corrado, Rajat Monga, KaiChen,Matthieu Devin, Quoc V. Le, Mark Z. Mao, Marc’Aurelio Ranzato, AndrewSenior, Paul Tucker, Ke Yang, and Andrew Y. Ng. Large scale distributeddeep networks. In NIPS, 2012.<a href="#fnref5" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn6"><p>Ian Goodfellow, Yoshua Bengio, and Aaron Courville. Deeplearning. Book in preparation for MIT Press, 2016.<a href="#fnref6"class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn7"><p>Sergey Ioffe and Christian Szegedy. Batch normalization:Accelerating deep network training by reducing internal covariate shift.In ICML, 2015.<a href="#fnref7" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn8"><p>Ian J. Goodfellow, Oriol Vinyals, and Andrew M.Saxe.Qualitatively characterizing neural network optimization problems.In ICLR, 2015.<a href="#fnref8" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn9"><p>Keith Bonawitz, Vladimir Ivanov, Ben Kreuter, AntonioMarcedone, H. Brendan McMahan, Sarvar Patel,Daniel Ramage, Aaron Segal,and Karn Seth. Practicalsecure aggregation for federated learning onuser-held data. In NIPS Workshop on Private Multi-Party MachineLearning, 2016.<a href="#fnref9" class="footnote-back"role="doc-backlink">↩︎</a></p></li><li id="fn10"><p>Jakub Konecnˇ y, H. Brendan McMahan, Felix X. Yu,´Peter Richtarik, Ananda Theertha Suresh, and Dave Bacon. Federatedlearning: Strategies for improving communication efficiency. In NIPSWorkshop on Private Multi-Party Machine Learning, 2016.<ahref="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></aside>]]></content>
      
      
      <categories>
          
          <category> 毕业设计 </category>
          
          <category> 论文阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 毕业设计 </tag>
            
            <tag> 小刘的 </tag>
            
            <tag> 联邦学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十五次课-状态分配</title>
      <link href="/2023/11/29/%E7%AC%AC%E5%8D%81%E4%BA%94%E6%AC%A1%E8%AF%BE/"/>
      <url>/2023/11/29/%E7%AC%AC%E5%8D%81%E4%BA%94%E6%AC%A1%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="第十五次课">第十五次课</h1><h2 id="三状态分配">三、状态分配</h2><p>状态分配：状态编码、状态赋值</p><p>状态分配的任务：确定编码长度，确定状态分配方案（即每个状态分配那个编码）</p><p>分配方案决定着实现电路的繁与简</p><p>基本思想：使得卡诺图里的 1 都相邻，便于化简</p><p>相邻法分配原则：</p><ol type="1"><li>在相同的输入条件下，具有相同次态的两个现态，应该分配相邻的编码</li><li>在相邻输入条件下，同一现态的不同次态，应该分配相邻的代码</li><li>输出完全相同的现态，应该尽可能分配相邻的代码</li><li>（以上三个有优先级，1 最高，2 次之）此外，一般将原始状态分配成 0态</li></ol><h2 id="四确定激励函数和输出函数">四、确定激励函数和输出函数</h2><p>触发器激励表：</p><h2 id="五电路的挂起与自启动">五、电路的“挂起”与自启动</h2><p>解决“挂起”方法:</p><ul><li>预置初值</li><li>设计自启动电路</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数电 </tag>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构-十四周周一最小生成树</title>
      <link href="/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%81%E5%9B%9B%E5%91%A8%E5%91%A8%E4%B8%80%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2023/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%81%E5%9B%9B%E5%91%A8%E5%91%A8%E4%B8%80%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="图的遍历">7.3图的遍历</h1><h2 id="求图的连通分量">3.求图的连通分量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Count_Component</span><span class="params">(AdjList g)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v = <span class="number">1</span>; v &lt;= g.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(v = <span class="number">1</span>; v &lt;= g.vexnum; v++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vistied[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count ++;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;连通分量d%包含一下顶点:&quot;</span>, count);</span><br><span class="line">           dfs(g, v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;/n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;共有%d个两连通分量&quot;</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最小生成树和最短路径">7.4最小生成树和最短路径</h1><h2 id="最小生成树">1.最小生成树</h2><p>带权连通图中，总的权值之和最小的带权生成树是最小生成树。也叫最小代价生成树、最小花费生成树</p><blockquote><p>Kruskal算法：</p><ol type="1"><li><p>设 T 的初始状态为空寂</p></li><li><p>当 T 中边数小于 n-1 时，做一下工作</p></li></ol></blockquote><pre><code>&gt;&gt;   （1）从 E 中选择权值最小的边（v, w），并删除&gt;&gt;   （2）所（v, w）不与 T 中的边一起构成回路，就把边（v, w）加入 T 中去</code></pre><h3 id="判断-t-中-边是否构成回路">判断 T 中 边是否构成回路</h3><p>（1）并查集（分类）：</p><p><并>：如果两个集合中两个元素有关系，就进行<strong>并</strong>预算<查>：查找给出的元素是哪个集合的</p><p>判断是否出回路：判断v，w是否属于同一集合，如果是同一集合就能构成回路</p><p>（2）DFS：判断从 v 是否能到 w，如果能到就能构成回路</p><blockquote><p>Prim算法：</p><ol type="1"><li><p>设 V(T) 的出台为空集（V(T)为落在生成树上的顶点集合）</p></li><li><p>在连通图中人选一顶点加入 V(T) 集合中去</p></li><li><p>将下列的步骤重复 n-1 次</p></li></ol></blockquote><pre><code> &gt; &gt;    （1）在 i 属于 V(T) ， j 不属于 V(T) 的边中，选择权值最小的便 （i，j） &gt; &gt;    （2）将 j 加入到 V(T) 里面去 &gt; &gt;    （3）输出 i，j 以及 $W_ij$</code></pre><h2 id="最短路径问题">2.最短路径问题</h2><h3 id="单源最短路径">（1）单源最短路径</h3><p>求从 <span class="math inline">\(v_0\)</span> ~ <spanclass="math inline">\(v_j\)</span> 的最短路径的话，从 <spanclass="math inline">\(v_0\)</span> 到中间任意结点都是最短路径</p>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 课堂笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构--邻接表</title>
      <link href="/2023/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
      <url>/2023/11/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%82%BB%E6%8E%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="今天讲图的邻接表">今天讲图的邻接表</h1><h2 id="图的存储">图的存储</h2><h3 id="邻接表存储">邻接表存储</h3><p>核心思想：对具有 n 个顶点的图，建立 n 个线性链表来存储该图</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build_adjlist</span><span class="params">(AgjListc Gga)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的遍历">图的遍历</h2><p>深度遍历dfs，广度遍历bfs</p><h3 id="深度优先搜索">深度优先搜索</h3><p>原则：从图中某个指定的顶点出发，先访问顶点 v ，然后从顶点 v未被访问过的一个邻接点出发，继续进行深度优先遍历，知道与 v相通的所有顶点都被访问；此时图中若还有未被访问过的顶点，则从另一个未被访问过的顶点出发重复上述过程，直到遍历全图</p><h3 id="广度优先遍历洪泛算法">广度优先遍历（洪泛算法）</h3><p>原则：从 v 出发，先遍历所有与 v 相通的顶点，再对每个顶点广度</p><h3 id="准备">准备</h3><p>要有一个标记是否访问过的数组</p><h3 id="深度优先搜索代码">深度优先搜索代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(AdjList g, <span class="type">int</span> v0)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]&quot;</span>, v0);</span><br><span class="line">    Visited[v0] == <span class="number">1</span>; <span class="comment">// 标记 v0 已经访问过</span></span><br><span class="line">    p = g[v0].link; <span class="comment">// 找 v0 的第一个邻接点</span></span><br><span class="line">    <span class="keyword">while</span>(p -&gt; next != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(Visited[p -&gt; adjvex] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            dfs(g, p-&gt;adjvex);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3id="广度优先查找某点到起始点的路径长度">广度优先查找某点到起始点的路径长度</h3><h3 id="为迷宫寻找最短路径">为迷宫寻找最短路径</h3>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 课堂笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十四次课-同步时序逻辑电路化简状态</title>
      <link href="/2023/11/24/%E7%AC%AC%E5%8D%81%E5%9B%9B%E6%AC%A1%E8%AF%BE/"/>
      <url>/2023/11/24/%E7%AC%AC%E5%8D%81%E5%9B%9B%E6%AC%A1%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="同步时序逻辑电路的设计">5.3同步时序逻辑电路的设计</h1><h2 id="二状态化简">二、状态化简</h2><ul><li>同步时序逻辑电路使用 <strong>触发器</strong> 组成储存电路，状态数<strong>N</strong> 将直接决定电路中所需要的触发器数量<strong>m</strong></li><li><span class="math inline">\(2^m-1\)</span> &lt; N &lt;= <spanclass="math inline">\(2^m\)</span></li><li>目的：得到最简状态图和最简状态表</li></ul><h3 id="完全定义状态表的化简">1.完全定义状态表的化简</h3><h4 id="化简的原理">（1）化简的原理</h4><ol type="1"><li><p>等效状态和等效类</p></li><li><p>（<span class="math inline">\(S_i\)</span>, <spanclass="math inline">\(S_j\)</span>）等效对</p></li><li><blockquote><p>根据原始状态表判断等效状态的方法</p><p>满足：</p><ul><li>输出相同</li><li>a次态相同，b次态交错或者为各自的现态，c次态循环或为等效对（满足a,b,c任何一个）</li></ul></blockquote></li><li><p>等效状态有传递性</p></li><li><p>等效类：彼此等效的状态形成的集合</p></li><li><p>最大等效类：一个等效类不是其他等效类的子集</p></li></ol><h4 id="利用隐含表进行状态化简">（2）利用隐含表进行状态化简</h4><h5 id="section">&lt;1&gt;</h5><p>原始状态表 ----(隐含表)----&gt; 寻找等效状态对 ----(传递性)----&gt;等效类(最大等效类)----(状态合并)----&gt; 最小化状态表</p><h5 id="寻找等效对">&lt;2&gt;寻找等效对。</h5><p>首先进行顺序比较，然后关联比较</p><blockquote><p>三种情况：确定等效√ 确定不等效 × 不确定 填写相关的状态对</p></blockquote><h5 id="求最大等效类">&lt;3&gt;求最大等效类</h5><blockquote><p>不应该出现相同的元素</p></blockquote><h5 id="做出最小状态表">&lt;4&gt; 做出最小状态表</h5><h3 id="不完全定义状态表的化简">2.不完全定义状态表的化简</h3><h4 id="相容状态和相容类">（1）相容状态和相容类</h4><h5 id="相容状态定义">&lt;1&gt;相容状态定义</h5><blockquote><p>假设状态 <span class="math inline">\(S_i\)</span> 和 <spanclass="math inline">\(S_j\)</span> 是不完全状态表中的两个状态，如果<em>对于所有有效的输入序列，分别从 <spanclass="math inline">\(S_i\)</span> 和 <spanclass="math inline">\(S_j\)</span>出发，做得到的输出相应序列完全相同（初步确定的那些位外）</em>，则状态<span class="math inline">\(S_i\)</span> 和 <spanclass="math inline">\(S_j\)</span> 是相容的。</p></blockquote><h5 id="判断相容对">&lt;2&gt;判断相容对</h5><blockquote><ol type="1"><li>输出完全相同，或者一个（或两个）输出不确定</li><li>a次态相同 b次态交错或者是各自的现态 c次态循环或者是相容对d次态中有不确定状态</li></ol></blockquote><p><strong>相容状态不具有传递性</strong></p><h5 id="相容类或者最大相容类">&lt;3&gt;相容类或者最大相容类</h5><ul><li>彼此相容的状态构成的集合，称为相容类</li><li>若一个相容类不是其他相容类的自己，则称此相容类为最大相容类</li></ul><h4 id="不完全定义状态表的化简-1">（2）不完全定义状态表的化简</h4><ol type="1"><li><p>利用隐含表，寻找相容对</p></li><li><p>利用状态合并图，寻找最大相容类</p><p><strong>状态合并图</strong> ： 快速找最大相容类的工具</p><ul><li>圆周上均匀分布的点 ----- 表示状态</li><li>点间连线 ----- 表示相容关系</li><li>所有点之间均有连线的多边形（即任一点和其他店均有连线） -----为相容类或者二最大相容类</li></ul></li><li><p>利用闭覆盖表，求最小闭覆盖</p><blockquote><p>闭合性：所选相容类集合中任意相容类，在原始状态表各种输入条件下产生的次态属于该相容类集合的某一个相容类</p></blockquote></li><li><p>做出最小状态表</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数电 </tag>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十三次课-同步时序逻辑电路初始状态图/表</title>
      <link href="/2023/11/24/%E7%AC%AC%E5%8D%81%E4%B8%89%E6%AC%A1%E8%AF%BE/"/>
      <url>/2023/11/24/%E7%AC%AC%E5%8D%81%E4%B8%89%E6%AC%A1%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="同步时序逻辑电路的设计">5.3同步时序逻辑电路的设计</h1><ul><li>基本任务：根据给定的功能描述，设计出相应的逻辑电路</li></ul><blockquote><ol type="1"><li>根据功能要求建立原始状态图和状态表</li><li>状态化简（消去多余状态）</li><li>状态分配（状态编码）</li><li>求输出函数和激励函数表达式</li><li>根据输出函数和激励函数的表达式画出逻辑电路</li></ol></blockquote><h2 id="一建立原始状态图和状态表">一、建立原始状态图和状态表</h2><blockquote><p>原始状态图（表）：根据逻辑功能的文字描述，直接建立起来的状态图（表）</p><ul><li>对设计要求的最原始的抽象，是设计电路的初始依据</li></ul></blockquote><h3 id="注意">注意</h3><p>建立原始状态图和原始状态表要从四个方面着手：</p><ol type="1"><li>确定电路模型（Mealy型还是Moore型）</li><li>设立电路初始状态</li><li>根据需要记忆的信息来增加新的状态</li><li>确定各个时刻电路的输出（在不同输入条件下，要确定输出）</li></ol><p>由于在开始时不知道要描述多少个状态，在原始状态表和原始状态图中一般用字母或者数字表示</p><blockquote><p>模⑤加1加2计数器（记满五个状态后，输出 1 ）</p><ol type="1"><li><p>有五个状态设为0，1，2，3，4，初始状态设0</p></li><li></li></ol><table><thead><tr class="header"><th style="text-align: center;">现态</th><th style="text-align: center;">次态，输出</th><th style="text-align: center;">次态，输出</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"></td><td style="text-align: center;">x = 0</td><td style="text-align: center;">x = 1</td></tr><tr class="even"><td style="text-align: center;">0</td><td style="text-align: center;">1/0</td><td style="text-align: center;">2/0</td></tr><tr class="odd"><td style="text-align: center;">1</td><td style="text-align: center;">2/0</td><td style="text-align: center;">4/0</td></tr><tr class="even"><td style="text-align: center;">2</td><td style="text-align: center;">3/0</td><td style="text-align: center;">1/0</td></tr><tr class="odd"><td style="text-align: center;">3</td><td style="text-align: center;">4/0</td><td style="text-align: center;">3/0</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">0/1</td><td style="text-align: center;">0/1</td></tr></tbody></table><ol start="3" type="1"><li><em>如果初始状态变成 3 ，那么 x = 0时，再回到 3 才输出 1</em></li></ol></blockquote><blockquote><p>序列检测器（检测 011）</p><h4 id="mealy">Mealy</h4><ol type="1"><li>由于状态数未知，设初始状态为A，A为与检测序列无关的序列</li><li>如果第一位输入1，我们想要的是0，次态还是A</li><li>如果从 A 状态检测到了0，变成状态B</li><li>从 B 检测 0，变为状态 B</li><li>从 B 检测 1，变成状态 C</li><li>从 C 检测 0，变成状态 B</li><li>从 C 检测 1，变成状态 D，输出1</li><li>从 D 检测 0，变成状态 B</li><li>从 D 检测 1，变成状态 A</li></ol><h4 id="moore">Moore</h4><ol type="1"><li>设 A 为初始状态，与检测序列无关</li><li>B表示检测到了 : 0, C : 01, C : 011</li><li>A/0 B/0 C/0 D/1</li></ol></blockquote><blockquote><p>炸弹引爆（检测 1111），炸掉后无次态</p><ol type="1"><li>设 A 为初始状态， B，C，D分别表示 1， 11， 111</li><li><img src="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231122092034707.png" alt="image-20231122092034707" style="zoom:50%;" /><img src="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231122092146265.png" alt="image-20231122092146265" style="zoom: 67%;" /></li></ol></blockquote><blockquote><p>检测串行输入的 8421BCD码是否合法，不合法输出 1</p><h4 id="mealy-1">Mealy</h4><p><em>串行码字检测和序列检测最大的区别就是串行码字检测时分组进行的，每组的检测过程相同。当码字最后一位输入后，电路转向为初始状态进行下一组检测，因此是Mealy型</em></p><p><img src="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/image-20231122094218323.png" alt="image-2023112209214135" style="zoom: 67%;" /></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 课堂笔记 </category>
          
          <category> 数电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小杜的 </tag>
            
            <tag> 数电 </tag>
            
            <tag> 课堂笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vhdl秒表代码注释-第一部分</title>
      <link href="/2023/11/20/vhdl%E7%A7%92%E8%A1%A8%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
      <url>/2023/11/20/vhdl%E7%A7%92%E8%A1%A8%E4%BB%A3%E7%A0%81%E6%B3%A8%E9%87%8A-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h1 id="vhdl秒表代码">vhdl秒表代码</h1><h2 id="关键字">关键字</h2><h3 id="architecture">architecture</h3><p>结构体描述设计实体内部的特性。结构体的书写格式如下：</p><blockquote><p>architecture 结构名字 of 实体名 is:内部信号、常量、数据类型、函数等的定义; begin:若干并行执行语句，具体描述结构体的功能和行为。 end 结构体名;</p></blockquote><ul><li>结构体内要求使用<strong>并行执行语句</strong>。</li><li>类似 <strong>if</strong> 之类的顺序执行语句，只要将它们放在进程语句<strong>process</strong> 语句之内即可。process语句是并行执行语句。</li></ul><h3 id="library">library</h3><blockquote><p>库用于存放预先编译好的程序包</p><p>程序包中定义了数据结构体、操作逻辑和原件等。主要是声明在设计或者实体中将用到的常数，数据类型，原件，子程序等。</p></blockquote><h3 id="signal信号">signal信号</h3><blockquote><p>信号表示逻辑门的输入或者输出</p><p>类似于连接线，也可以表达存储元件的状态。</p><p>信号通常在结构体，程序包和实体中说明</p></blockquote><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 信号定义语句： signal 信号名 : 数据类型 := 初始值</span></span><br><span class="line"><span class="keyword">signal</span> clock : <span class="built_in">bit</span> = <span class="string">&#x27;0&#x27;</span>; <span class="comment">-- 定义时钟信号的数据类型，初始值为0</span></span><br><span class="line"><span class="keyword">signal</span> count : <span class="built_in">BIT_VECTOR</span>(<span class="number">3</span> <span class="keyword">DOWNTO</span> <span class="number">0</span>); <span class="comment">-- 定义 count 为四位位矢量</span></span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 信号赋值语句： 目标信号名 &lt;= 表达式;</span></span><br><span class="line">x &lt;= <span class="number">9</span>;</span><br><span class="line">Z &lt;= x <span class="keyword">after</span> <span class="number">5</span> ns; <span class="comment">-- 在 5ns 后将 x 赋值给 Z</span></span><br></pre></td></tr></table></figure><h3 id="process">process</h3><p>​process语句通常称之为进程语句，本质上他描述了一个功能独立的电路块；</p><p>​ process语句是一个并行执行的语句，但是process内部是顺序执行语句</p><blockquote><p>[ 进程名: ] process (敏感信号1，敏感信号2，... ，敏感信号n) [若干变量说明语句 ] begin [ 若干顺序说明语句] end process [ 进程名 ];</p></blockquote><ul><li>由于结构体中各并行执行语句都是独立的电路块，因此不允许两个或者两个以上的并行语句对对同一个信号赋值。</li></ul><h3 id="variable">variable</h3><blockquote><p>变量只能在进程语句、函数语句和过程语句结构中使用。变量的赋值是直接的，非预制的，分配给变量的值立即成为当前值，变量不能表达“连线”或者存储元件，不能设置传输延迟量</p></blockquote><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 变量定义语句： variable 变量名 ：数据类型 := 初始值；</span></span><br><span class="line"><span class="keyword">variable</span> count : <span class="built_in">integer</span> <span class="number">0</span> <span class="keyword">to</span> <span class="number">255</span> := <span class="number">20</span>;</span><br><span class="line"><span class="comment">-- 定义变量 count 整数变量，变化范围是 2~255，出初始值是 20；</span></span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 变量赋值语句： 变量名 := 表达式</span></span><br><span class="line">x := <span class="number">10.0</span>;</span><br><span class="line">y = <span class="number">1.5</span> + x;</span><br><span class="line">A(<span class="number">3</span> <span class="keyword">to</span> <span class="number">6</span>) := (<span class="string">&quot;1101&quot;</span>); <span class="comment">-- 一个矢量的赋值</span></span><br></pre></td></tr></table></figure><h2 id="数据类型转换">数据类型转换</h2><p>​ VHDL 是强定义类型语言，不同类型的数据不能进行运算和直接赋值</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 类型表记法</span></span><br><span class="line"><span class="keyword">variable</span> A : <span class="built_in">integer</span>;</span><br><span class="line"><span class="keyword">variable</span> B : real;</span><br><span class="line"><span class="comment">-- real 实数</span></span><br><span class="line">A = <span class="built_in">integer</span>(B);</span><br><span class="line">B = real(A);</span><br></pre></td></tr></table></figure><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 函数法</span></span><br><span class="line">Conv_Integer(A);</span><br><span class="line"><span class="comment">-- 由 std_logic 转换为 integer 类型，在 std_logic_unsigned 包中。</span></span><br></pre></td></tr></table></figure><h2 id="常用语句">常用语句</h2><h3 id="case">case</h3><blockquote><p>case语句是顺序执行语句，常用于描述总线的行为、编译器和译码器的结构以及状态机等等。case语句的可读性好，非常简洁4</p></blockquote><blockquote><p>case 条件表达式 is: when 条件表达式值1 =&gt; 若干顺序执行语句 when条件表达式值2 =&gt; 若干顺序执行语句 ...... when 条件表达式值n =&gt;若干顺序执行语句 when others =&gt; 若干顺序执行语句 end case;</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 花自向阳开 </category>
          
          <category> 数电VHDL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 花自向阳开 </tag>
            
            <tag> 小杜的 </tag>
            
            <tag> 数电 </tag>
            
            <tag> VHDL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基本使用</title>
      <link href="/2023/10/25/markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/10/25/markdown%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown基本使用">markdown基本使用</h1><h2 id="标题">1. 标题</h2><ul><li><p>标题有一级标题到六级标题</p></li><li><p>代码形式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一级标题：<span class="comment"># + &#x27;内容&#x27;</span></span><br><span class="line">二级标题：<span class="comment">## + &#x27;内容&#x27;</span></span><br><span class="line">三级标题：<span class="comment">### + &#x27;内容&#x27;</span></span><br><span class="line">……</span><br><span class="line">六级标题：<span class="comment">###### + &#x27;内容&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>注意 # 和 ’内容‘ 之间有空格</p></li><li><p>显示样式</p><h1 id="一级标题">一级标题</h1><h2 id="二级标题">二级标题</h2><h3 id="三级标题">三级标题</h3><h4 id="四级标题">四级标题</h4><h5 id="五级标题">五级标题</h5><h6 id="六级标题">六级标题</h6></li></ul><h2 id="字体">2. 字体</h2><h3 id="斜体">斜体：</h3><ul><li><p>代码形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><p><em>斜体</em></p></li></ul><h3 id="加粗">加粗：</h3><ul><li><p>代码形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**加粗**</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><p><strong>加粗</strong></p></li></ul><h3 id="加粗斜体">加粗斜体：</h3><ul><li><p>代码形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">***加粗斜体***</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><p><strong><em>加粗斜体</em></strong></p></li></ul><h3 id="删除">删除</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除~~</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><p><del>删除</del></p></li></ul><h2 id="引用">3. 引用</h2><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用（有空格）</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><blockquote><p>引用</p></blockquote></li></ul><h2 id="分割线">4. 分割线</h2><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">or </span><br><span class="line">***</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p></li></ul><hr /><hr /><hr /><hr /><h2 id="图片">5. 图片</h2><h3 id="本地图片">本地图片：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![自命名照片的名字](照片的地址)</span><br></pre></td></tr></table></figure></li><li><p>显示样式： <imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/F16D808895D92E6ED21170D8F287122A.jpg"alt="图片" /></p></li></ul><h3 id="网络图片">网络图片：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![自命名照片的名字](照片的链接)</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p></li></ul><figure><imgsrc="https://blog-1313503696.cos.ap-nanjing.myqcloud.com/blog/R.466bb61cd7cf4e8b7d9cdf645add1d6e"alt="002" /><figcaption aria-hidden="true">002</figcaption></figure><h2 id="超链接">6. 超链接</h2><ul><li><p>代码形式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[自命名链接的名字](链接)</span><br></pre></td></tr></table></figure></li><li><p>显示样式： <a href="?????">链接</a></p></li></ul><h2 id="列表">7. 列表</h2><h3 id="有序列表">有序列表：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 001</span><br><span class="line">2. 002</span><br><span class="line">3. 003</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><ol type="1"><li>001</li><li>002</li><li>003</li></ol></li></ul><h3 id="无序列表">无序列表：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 001</span><br><span class="line">- 002</span><br><span class="line">- 003</span><br><span class="line">- </span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><ul><li>001</li><li>002</li><li>003</li><li></li></ul></li></ul><h2 id="表格">8. 表格</h2><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">| name  | age  | sex  |</span><br><span class="line">| ----- | ---- | ---- |</span><br><span class="line">| Jerry | 19   | 女   |</span><br><span class="line">| Tom   | 21   | 男   |</span><br><span class="line">| ……    | ……   | ……   |</span><br><span class="line">| ……    | ……   |      |</span><br><span class="line">| ……    |      |      |</span><br><span class="line">|       |      |      |</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p></li></ul><table><thead><tr class="header"><th>name</th><th>age</th><th>sex</th></tr></thead><tbody><tr class="odd"><td>Jerry</td><td>19</td><td>女</td></tr><tr class="even"><td>Tom</td><td>21</td><td>男</td></tr><tr class="odd"><td>……</td><td>……</td><td>……</td></tr><tr class="even"><td>……</td><td>……</td><td></td></tr><tr class="odd"><td>……</td><td></td><td></td></tr><tr class="even"><td></td><td></td><td></td></tr></tbody></table><ul><li>快捷键： Ctrl + T</li></ul><h2 id="代码">8.代码</h2><h3 id="单行代码">单行代码：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`hello`</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><p><code>hello</code></p></li></ul><h3 id="多行代码">多行代码：</h3><ul><li><p>代码样式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">``` java</span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello and welcome!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt;= 5; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure></li><li><p>显示样式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;Hello and welcome!&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 花自向阳开 </category>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 花自向阳开 </tag>
            
            <tag> 小杜的 </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>加密内容</title>
      <link href="/Agreement/index.html"/>
      <url>/Agreement/index.html</url>
      
        <content type="html"><![CDATA[<div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2023</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-29</p></div></div><div class='timeline-item-content'><pre><code>x:2500 小杜乖乖走路+700y:13 z:7 偷看老公的纸条-1 要求老公陪买实验报告-1m:1小杜发夹购买券:3</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-27</p></div></div><div class='timeline-item-content'><pre><code>x:1800y:13 小刘乖乖吃饭z:9m:1小杜发夹购买券:3</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-26</p></div></div><div class='timeline-item-content'><pre><code>x:1800y:11 支使老婆接水-1z:9 买发夹-1 走路+7m:1</code></pre></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-23</p></div></div><div class='timeline-item-content'><pre><code>x:1800y:12z:3m:1</code></pre></div></div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2023</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-24</p></div></div><div class='timeline-item-content'><p>带若若第一次吃海底捞</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-23</p></div></div><div class='timeline-item-content'><p>小杜和小刘小破站正式运行</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-23</p></div></div><div class='timeline-item-content'><p>小杜和小刘的第一个'宝宝' 杜沃若 出生</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-13</p></div></div><div class='timeline-item-content'><p>小刘给小杜编毛毯</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-10</p></div></div><div class='timeline-item-content'><p>通关《双人成行》</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>05-20</p></div></div><div class='timeline-item-content'><p>小杜给小刘捡了一大捧茉莉花花</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-23</p></div></div><div class='timeline-item-content'><p>小刘给小杜做郁金香蛋糕</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-15</p></div></div><div class='timeline-item-content'><p>看郁金香and做戒指</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>04-14</p></div></div><div class='timeline-item-content'><p>小刘陪小杜修手机</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-25</p></div></div><div class='timeline-item-content'><p>铃芽之旅</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-12</p></div></div><div class='timeline-item-content'><p>小杜四级考试（小刘六级）</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-03</p></div></div><div class='timeline-item-content'><p>陪小刘看午夜场电影</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-02</p></div></div><div class='timeline-item-content'><p>小杜的新身份--小刘的老婆</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-01</p></div></div><div class='timeline-item-content'><p>小刘晚上陪小杜写物理实验</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>03-01</p></div></div><div class='timeline-item-content'><p>小刘凌晨偷偷表白</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-28</p></div></div><div class='timeline-item-content'><p>小刘带小杜吃驴肉火烧</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-28</p></div></div><div class='timeline-item-content'><p>小杜给小刘带绿色的花花</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-26</p></div></div><div class='timeline-item-content'><p>小刘带小杜看电影</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-23</p></div></div><div class='timeline-item-content'><p>给小刘送小蛋糕</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>02-11</p></div></div><div class='timeline-item-content'><p>小杜和小刘的开学会面</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>01-21</p></div></div><div class='timeline-item-content'><p>小刘给小杜发漂亮的新年红包</p></div></div></div><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>2022</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>12-08</p></div></div><div class='timeline-item-content'><p>小杜把小刘的智能车车寄到河南</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-30</p></div></div><div class='timeline-item-content'><p>小杜把小刘的智能车车带回山东</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11-18</p></div></div><div class='timeline-item-content'><p>疫情来袭</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>10-22</p></div></div><div class='timeline-item-content'><p>小刘和小杜的遇见</p></div></div></div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友情链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
